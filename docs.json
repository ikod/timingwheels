[
	{
		"kind": "module",
		"file": "source/timingwheels/timingwheels_impl.d",
		"members": [
			{
				"line": 60,
				"kind": "class",
				"char": 1,
				"base": "object.Exception",
				"members": [
					{
						"parameters": [
							{
								"deco": "Aya",
								"name": "msg"
							},
							{
								"deco": "Aya",
								"default": "__FILE__",
								"name": "file"
							},
							{
								"deco": "m",
								"default": "cast(ulong)__LINE__",
								"name": "line"
							}
						],
						"line": 63,
						"kind": "constructor",
						"originalType": "@nogc @safe (string msg, string file = __FILE__, size_t line = __LINE__)",
						"char": 5,
						"name": "this",
						"deco": "FNiNfAyaQdmZC12timingwheels17timingwheels_impl18ScheduleTimerError",
						"endchar": 5,
						"endline": 66,
						"comment": "\n"
					}
				],
				"name": "ScheduleTimerError",
				"comment": "\nscheduling error occurs at schedule() when ticks == 0 or timer already scheduled.\n\n\n"
			},
			{
				"line": 71,
				"kind": "class",
				"char": 1,
				"base": "object.Exception",
				"members": [
					{
						"parameters": [
							{
								"deco": "Aya",
								"name": "msg"
							},
							{
								"deco": "Aya",
								"default": "__FILE__",
								"name": "file"
							},
							{
								"deco": "m",
								"default": "cast(ulong)__LINE__",
								"name": "line"
							}
						],
						"line": 74,
						"kind": "constructor",
						"originalType": "@nogc @safe (string msg, string file = __FILE__, size_t line = __LINE__)",
						"char": 5,
						"name": "this",
						"deco": "FNiNfAyaQdmZC12timingwheels17timingwheels_impl16CancelTimerError",
						"endchar": 5,
						"endline": 77,
						"comment": "\n"
					}
				],
				"name": "CancelTimerError",
				"comment": "\nCancel timer error occurs if you try to cancel timer which is not scheduled.\n\n"
			},
			{
				"line": 82,
				"kind": "class",
				"char": 1,
				"base": "object.Exception",
				"members": [
					{
						"parameters": [
							{
								"deco": "Aya",
								"name": "msg"
							},
							{
								"deco": "Aya",
								"default": "__FILE__",
								"name": "file"
							},
							{
								"deco": "m",
								"default": "cast(ulong)__LINE__",
								"name": "line"
							}
						],
						"line": 87,
						"kind": "constructor",
						"originalType": "@nogc @safe (string msg, string file = __FILE__, size_t line = __LINE__)",
						"char": 5,
						"name": "this",
						"deco": "FNiNfAyaQdmZC12timingwheels17timingwheels_impl17AdvanceWheelError",
						"endchar": 5,
						"endline": 90,
						"comment": "\n\n\n"
					}
				],
				"name": "AdvanceWheelError",
				"comment": "\nAdvancing error occurs if number of ticks for advance not in range 0<t<=256\n\n"
			},
			{
				"parameters": [
					{
						"kind": "type",
						"name": "T"
					}
				],
				"line": 212,
				"kind": "template",
				"char": 1,
				"members": [
					{
						"kind": "struct",
						"char": 1,
						"members": [
							{
								"parameters": [
									{
										"kind": "type",
										"name": "T"
									}
								],
								"line": 371,
								"kind": "template",
								"char": 10,
								"members": [
									{
										"parameters": [
											{
												"type": "T",
												"name": "timer"
											},
											{
												"deco": "m",
												"storageClass": [
													"const"
												],
												"name": "ticks"
											}
										],
										"line": 371,
										"kind": "function",
										"char": 10,
										"name": "schedule",
										"type": "void(T timer, const ulong ticks)",
										"endchar": 5,
										"endline": 398
									}
								],
								"name": "schedule",
								"comment": "\nSchedule timer to future\nParams:\ntimer = timer to schedule;\nticks = ticks in the future to schedule timer. (0 < ticks < ulong.max);\nReturns:\nvoid\nThrows:\nScheduleTimerError\nwhen thicks == 0\nor when timer already scheduled\n\n"
							},
							{
								"parameters": [
									{
										"kind": "type",
										"name": "T"
									}
								],
								"line": 407,
								"kind": "template",
								"char": 10,
								"members": [
									{
										"parameters": [
											{
												"type": "T",
												"name": "timer"
											}
										],
										"line": 407,
										"kind": "function",
										"char": 10,
										"name": "cancel",
										"type": "void(T timer)",
										"endchar": 5,
										"endline": 423
									}
								],
								"name": "cancel",
								"comment": "Cancel timer\nParams:\ntimer = timer to cancel\nReturns:\nvoid\nThrows:\nCancelTimerError\nif timer not in wheel\n"
							},
							{
								"line": 430,
								"kind": "function",
								"char": 9,
								"name": "ticksUntilNextEvent",
								"type": "int()",
								"endchar": 5,
								"endline": 449,
								"comment": "\ncount \"empty\" ticks - slots without events.\nIf you have empty ticks it is safe to sleep - you will not miss anything, just wake up\nat the time when next timer have to be processed.\nReturns: number of empty ticks.\n\n"
							},
							{
								"parameters": [
									{
										"type": "Duration",
										"storageClass": [
											"const"
										],
										"name": "tick"
									}
								],
								"line": 455,
								"kind": "function",
								"char": 14,
								"name": "timeUntilNextEvent",
								"type": "Duration(const Duration tick)",
								"endchar": 5,
								"endline": 465,
								"comment": "Time until next scheduled timer event.\nParams:\ntick = your accepted tick duration.\nReturns: msecs until next event. Can be zero or negative in case you have already expired events.\n\n"
							},
							{
								"parameters": [
									{
										"kind": "this",
										"name": "W"
									}
								],
								"line": 473,
								"kind": "template",
								"char": 10,
								"members": [
									{
										"storageClass": [
											"auto"
										],
										"parameters": [
											{
												"deco": "m",
												"name": "ticks"
											}
										],
										"line": 473,
										"kind": "function",
										"char": 10,
										"name": "advance",
										"type": "(ulong ticks)",
										"endchar": 5,
										"endline": 525
									}
								],
								"name": "advance",
								"comment": "\nAdnvance wheel and return all timers expired during wheel turn.\n\nParams:\nticks = how many ticks to advance. Must be in range 0 <= 256\nReturns: list of expired timers\n\n"
							}
						],
						"line": 212,
						"name": "TimingWheels"
					}
				],
				"name": "TimingWheels",
				"comment": "\nThis structure implements scheme 6.2 thom the\nhttp://www.cs.columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf\nIt supports several primitives:\n1. schedule timer in the future.\n2. cancel timer.\n3. time step (advance) - all timers expired at current time tick are extracted from wheels.\nEach operation take O(1) time.\n\nExample:\n$(DDOX_UNITTEST_HEADER __unittest_L679_C1)\n---\nimport std;\nglobalLogLevel = LogLevel.info;\nauto rnd = Random(142);\n\n/// track execution\nint  counter;\nSysTime last = Clock.currTime;\n\n/// this is our Timer\nclass Timer\n{\n    static ulong __id;\n    private ulong _id;\n    private string _name;\n    this(string name)\n    {\n        _id = __id++;\n        _name = name;\n    }\n    /// must provide id() method\n    ulong id()\n    {\n        return _id;\n    }\n}\n\nenum IOWakeUpInterval = 100; // to simulate random IO wakeups in interval 0 - 100.msecs\n\n// each tick span 5 msecs - this is our link with time in reality\nenum Tick = 5.msecs;\nTimingWheels!Timer w;\n\nauto durationToTicks(Duration d)\n{\n    return d/Tick;\n}\nvoid process_timer(Timer t)\n{\n    switch(t._name)\n    {\n        case \"periodic\":\n            writefln(\"@ %s - delta: %sms (should be 50ms)\", t._name, (Clock.currTime - last).split!\"msecs\".msecs);\n            last = Clock.currTime;\n            counter++;\n            w.schedule(t, durationToTicks(50.msecs)); // rearm\n            break;\n        default:\n            writefln(\"@ %s\", t._name);\n            break;\n    }\n}\n\n//\n// start one arbitrary timer and one periodic timer\n//\nauto some_timer = new Timer(\"some\");\nauto periodic_timer = new Timer(\"periodic\");\nw.schedule(some_timer, durationToTicks(32.msecs));\nw.schedule(periodic_timer, durationToTicks(50.msecs));\n\nwhile(counter < 10)\n{\n    auto randomIoInterval = uniform(0, IOWakeUpInterval, rnd).msecs;\n    auto nextTimerEvent = max(w.timeUntilNextEvent(Tick), 0.msecs);\n    // wait for what should happen earlier\n    auto time_to_sleep = min(randomIoInterval, nextTimerEvent);\n    writefln(\"* sleep until timer event or random I/O for %s\", time_to_sleep);\n    Thread.sleep(time_to_sleep);\n    // if we waked up early by the IO event then timeUntilNextEvent will be positive\n    // otherwise it will be <= 0 and we have something to process.\n    while(w.timeUntilNextEvent(Tick) <= 0.msecs)\n    {\n        auto ticks = w.ticksUntilNextEvent();\n        auto wr = w.advance(ticks);\n        foreach(t; wr.timers)\n        {\n            process_timer(t);\n        }\n    }\n    // some random processing time\n    Thread.sleep(uniform(0, 5, rnd).msecs);\n}\n\n---\n$(DDOX_UNITTEST_FOOTER __unittest_L679_C1)\n"
			}
		],
		"comment": "\n",
		"name": "timingwheels.timingwheels_impl"
	}
]